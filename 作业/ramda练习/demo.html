<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script src="./ramda.min.js"></script>

    <script>
      const curry = R.curry;
      let match = curry((what, str) => str.match(what));
      let replace = curry((what, replacement, str) =>
        str.replace(what, replacement)
      );
      let filter = curry((f, ary) => ary.filter(f));
      let reduce = curry((f, init, ary) => ary.reduce(f, init));
      let split = curry((gap, str) => str.split(gap));
      let map = curry((f, ary) => ary.map(f));
      let hasSpaces = match(/\s+/g);
      let findSpaces = filter(hasSpaces);

      let noVowels = replace(/[aeiou]/gi);
      let censored = noVowels("*");
      //局部调用, 之传给函数一部分参数, 用以减少样板文件代码
      {
        // 用 map 简单地把参数是单个元素的函数包裹一下,就能把它转换成参数为数组的函数.
        let getChildren = x => x.childNodes;
        let allTheChildren = map(getChildren);
        {
          // 使用普通map来写
          // 参数的顺序发生变化
          let allTheChildren = elements => R.map(elements, getChildren);
        }
      }
      // 通常不定义直接操作数组的函数,因为秩序内联调用 map(getChildren)就能达到目的.这一点同样适用于 sort, filter 以及其他的高阶函数(higher order function) (高阶函数:参数或返回值为函数的函数)
      // 练习
      // 通过局部调用（partial apply）移除所有参数
      {
        let words = function(str) {
          return split(" ", str);
        };
      }
      let words = split("");
      // 使用 `map` 创建一个新的 `words` 函数，使之能够操作字符串数组
      {
        let sentences = undefined;
      }
      let sentences = map(words);
      // 通过局部调用（partial apply）移除所有参数
      {
        let filterQs = function(xs) {
          return filter(function(x) {
            return match(/q/i, x);
          }, xs);
        };
        filterQs = xs => filter(x => match(/q/i, x), xs);
      }
      let filterQs = filter(match(/q/i));
      // 练习 3
      {
        //==============
        // 使用帮助函数 `_keepHighest` 重构 `max` 使之成为 curry 函数

        // 无须改动:
        let _keepHighest = function(x, y) {
          return x >= y ? x : y;
        };

        // 重构这段代码:
        let max = function(xs) {
          return reduce(
            function(acc, x) {
              return _keepHighest(acc, x);
            },
            -Infinity,
            xs
          );
        };
        max = xs => reduce((acc, x) => _keepHighest(acc, x), -Infinity, xs);
      }
      let _keepHighest = function(x, y) {
        return x >= y ? x : y;
      };
      let max = reduce(_keepHighest, -Infinity);
    </script>
  </body>
</html>
