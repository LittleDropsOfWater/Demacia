#函数式编程
##函子

面向对象设计，内部状态难以追踪。

##一等公民的函数
函数不特殊,你可以像对待任何其他数据类型一样使用函数，存在数组里，当参数传递，赋值给变量...等等。
很多人对这一点并不了解，看以下这个例子：
```javascript
const hi = name => `Hi ${name}`;
const greeting = name => hi(name);
```
这里的greeting指向的那个把`hi`包了一层的包裹函数完全是多余的.为什么呢?因为JavaScript的函数是*可调用的*的,当`hi`后面紧跟`()`的时候会运行并返回一个值;如果没有`()`,`hi`就简单的返回存到这个变量里的函数.
`greeting`只不过是转了个身如何以相同的参数调用了`hi`函数而已,因此可以这么写:
```javascript
const greeting = hi;
greeting("times"); // "Hi times"
```
换句话说,`hi`已经是个接受一个参数的函数了,为何要再定义一个额外的包裹函数,而它仅仅是用这个相同的参数调用`hi`?完全没道理.就像在秋天开着空调然后裹着厚被子睡.真实脱裤子放屁多此一举.
用一个函数把另一个函数抱起来,目的仅仅是延迟执行,真的是非常糟糕的编程习惯.(且和可维护性密切相关.)
```javascript
// 太傻了
const getServerStuff = callback => ajaxCall(json => callback(json));

// 这才像样
const getServerStuff = ajaxCall;
```
```javascript
// 这行
ajaxCall(json => callback(json));

// 等价于这行
ajaxCall(callback);

// 那么，重构下 getServerStuff
const getServerStuff = callback => ajaxCall(callback);

// ...就等于
const getServerStuff = ajaxCall // <-- 看，没有括号哦
```
避免函数的无用嵌套.
```javascript
const BlogController = {
  index(posts) { return Views.index(posts); },
  show(post) { return Views.show(post); },
  create(attrs) { return Db.create(attrs); },
  update(post, attrs) { return Db.update(post, attrs); },
  destroy(post) { return Db.destroy(post); },
};
```
这个可笑的控制器（controller）99% 的代码都是垃圾。我们可以把它重写成这样：
```
const BlogController = {
  index: Views.index,
  show: Views.show,
  create: Db.create,
  update: Db.update,
  destroy: Db.destroy,
};
```
...或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已。
###为何钟爱一等公民?
添加没有实际用处的间接层实现起来容易,但这样除了徒增代码量,提高维护和检索代码的成本外,没有任何用处.
除了删除不必要的函数,正确地为参数命令也必不可少.
```JavaScript
// 只针对当前的博客
const validArticles = articles =>
  articles.filter(article => article !== null && article !== undefined),

// 对未来的项目更友好
const compact = xs => xs.filter(x => x !== null && x !== undefined);
```
小心this,函数时编程中根本用不到它.
高度的抽象.对行为的分离.设置通用的函数.
##纯函数的好处
###再次强调"纯"
纯函数的概念.
>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

比如slice和splice,这两个函数作用类似.`slice`符合纯函数的定义是因为对相同的输入它保证能够返回相同的输出.而`splice`却会嚼烂调用它的那个数组,然后再吐出来;这就产生可观察到的副作用,即猪哥哥数组永久的改变了.

函数时编程中,我们讨厌这种会*改变*数据的笨函数.我们追求可靠的每次都能返回同样结果的函数.

来看看另一个例子.
```JavaScript
// 不纯的
var minimum = 21;

var checkAge = function(age) {
  return age >= minimum;
};


// 纯的
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
```
不纯的版本中,`checkAge`的结果取决于`minimum`这个可变变量的值.换句话说,他取决于系统状态(system state).因为它引入了外部的环境,从而增加了认知负荷(cognitive load).

这个例子可能还不是那么明显，但这种依赖状态是影响系统复杂度的罪魁祸首（http://www.curtclifton.net/storage/papers/MoseleyMarks06a.pdf ）。输入值之外的因素能够左右 checkAge 的返回值，不仅让它变得不纯，而且导致每次我们思考整个软件的时候都痛苦不堪。

另一方面,使用纯函数的形式,函数能够做到自给自足.我们也可以让`minimun`成为一个不可变(immutable)对象,这样就能保留纯粹想,因为状态不会有变化.要实现这个效果,必须得创建一个对象,然后调用`Object.freeze`方法:
```JavaScript
var immutableState = Object.freeze({
  minimum: 21
});
```
###副作用可能包括...
*纯函数*定义中提到的万分邪恶的*副作用*到底是什么?"作用"我们可以理解为一切除结果计算之外发生的事情.
"作用"本身没什么坏处,而且在本书后面的章节你随处可见它的身影."副作用"的关键部分在于"副".就像一潭死水中的"水"本身并不是幼虫的培养起,"死"才是生成虫群的原因.同理,副作用中的"副"是滋生bug 的温床.
>副作用是在计算结果的过程中,系统状态的一种变化,或者与外部世界进行的*可观察*的交互.

副作用可能包含,但不限于:
- 更改文件系统
- 往数据库插入记录
- 发送一个http请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM查询
- 访问系统状态

这个列表还可以继续写下去.概括来讲,只要是跟函数外部环境发生的