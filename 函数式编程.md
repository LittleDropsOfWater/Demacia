#函数式编程
##函子

面向对象设计，内部状态难以追踪。

##一等公民的函数
像对待任何其他数据类型一样使用函数，存在数组里，当参数传递，赋值给变量。
很多人对这一点并不了解，看以下这个例子：
```javascript
const hi = name => `Hi ${name}`;
const greeting = name => hi(name);
```
这里的greeting指向的那个把`hi`包了一层的包裹函数完全是多余的.为什么呢?因为JavaScript的函数是*可调用的*的,当`hi`后面紧跟`()`的时候会运行并返回一个值;如果没有`()`,`hi`就简单的返回存到这个变量里的函数.
`greeting`只不过是转了个身如何以相同的参数调用了`hi`函数而已,因此可以这么写:
```javascript
const greeting = hi;
greeting("times"); // "Hi times"
```
换句话说,`hi`已经是个接受一个参数的函数了,为何要再定义一个额外的包裹函数,而它仅仅是用这个相同的参数调用`hi`?完全没道理.就像在秋天开着空调然后裹着厚被子睡.真实脱裤子放屁多此一举.
用一个函数把另一个函数抱起来,目的仅仅是延迟执行,真的是非常糟糕的编程习惯.(且和可维护性密切相关.)
```javascript
// 太傻了
const getServerStuff = callback => ajaxCall(json => callback(json));

// 这才像样
const getServerStuff = ajaxCall;
```
```javascript
// 这行
ajaxCall(json => callback(json));

// 等价于这行
ajaxCall(callback);

// 那么，重构下 getServerStuff
const getServerStuff = callback => ajaxCall(callback);

// ...就等于
const getServerStuff = ajaxCall // <-- 看，没有括号哦
```
避免函数的无用嵌套.
```javascript
const BlogController = {
  index(posts) { return Views.index(posts); },
  show(post) { return Views.show(post); },
  create(attrs) { return Db.create(attrs); },
  update(post, attrs) { return Db.update(post, attrs); },
  destroy(post) { return Db.destroy(post); },
};
```
这个可笑的控制器（controller）99% 的代码都是垃圾。我们可以把它重写成这样：
```
const BlogController = {
  index: Views.index,
  show: Views.show,
  create: Db.create,
  update: Db.update,
  destroy: Db.destroy,
};
```
...或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已。
高度的抽象.对行为的分离.设置通用的函数.
